// Simple client-side search for the prompt engineering blog

document.addEventListener('DOMContentLoaded', function() {
  const searchInput = document.getElementById('search-input');
  const searchResults = document.getElementById('search-results');
  const searchContainer = document.querySelector('.search-container');
  let searchData;
  
  // Fetch the search data (this would be generated by Jekyll)
  fetch('/search.json')
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      searchData = data;
    })
    .catch(error => {
      console.error('Error fetching search data:', error);
      // If the search.json file doesn't exist yet, use a placeholder for development
      searchData = [];
      console.log('Using empty search data for development');
    });

  // Handle search input
  if (searchInput) {
    searchInput.addEventListener('input', function() {
      const query = this.value.toLowerCase().trim();
      
      // Clear results if query is empty
      if (!query) {
        searchResults.innerHTML = '';
        searchContainer.classList.remove('has-results');
        return;
      }
      
      if (!searchData || searchData.length === 0) {
        searchResults.innerHTML = '<li class="no-results">Search data is still loading or unavailable.</li>';
        searchContainer.classList.add('has-results');
        return;
      }
      
      // Filter results
      const results = searchData.filter(item => {
        const titleMatch = item.title.toLowerCase().includes(query);
        const contentMatch = item.content.toLowerCase().includes(query);
        const tagsMatch = item.tags && item.tags.some(tag => tag.toLowerCase().includes(query));
        const categoriesMatch = item.categories && item.categories.some(cat => cat.toLowerCase().includes(query));
        
        return titleMatch || contentMatch || tagsMatch || categoriesMatch;
      });
      
      // Display results
      if (results.length === 0) {
        searchResults.innerHTML = '<li class="no-results">No results found for "' + query + '"</li>';
      } else {
        const resultsHtml = results.map(item => {
          return `
            <li class="search-result-item">
              <a href="${item.url}">
                <h3>${item.title}</h3>
                <p class="search-result-date">${item.date}</p>
                <p class="search-result-excerpt">${getExcerptWithHighlight(item.content, query)}</p>
              </a>
            </li>
          `;
        }).join('');
        
        searchResults.innerHTML = resultsHtml;
      }
      
      searchContainer.classList.add('has-results');
    });
    
    // Close search results when clicking outside
    document.addEventListener('click', function(e) {
      if (!searchContainer.contains(e.target)) {
        searchResults.innerHTML = '';
        searchContainer.classList.remove('has-results');
      }
    });
  }
  
  // Helper function to get an excerpt with the query highlighted
  function getExcerptWithHighlight(content, query) {
    // Get a portion of the content around the query
    const maxLength = 150;
    const lcContent = content.toLowerCase();
    let index = lcContent.indexOf(query);
    
    if (index === -1) return content.substring(0, maxLength) + '...';
    
    // Get a substring around the first match
    let start = Math.max(0, index - 60);
    let end = Math.min(content.length, index + query.length + 60);
    
    // Adjust to not cut words
    while (start > 0 && content[start] !== ' ') start--;
    while (end < content.length && content[end] !== ' ') end++;
    
    let excerpt = content.substring(start, end).trim();
    
    // Add ellipsis if we're not at the beginning or end
    if (start > 0) excerpt = '...' + excerpt;
    if (end < content.length) excerpt += '...';
    
    // Highlight the query term
    const regex = new RegExp('(' + escapeRegExp(query) + ')', 'gi');
    return excerpt.replace(regex, '<strong>$1</strong>');
  }
  
  // Helper to escape regex special characters
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
});